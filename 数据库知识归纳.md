[TOC]

# 1. 事务

## 1.1. 事务的特性

1. 原子性(Atomicity)

   原子性保证一个事务内的所有事务单元（对数据库的操作）那么全部执行成功，要么全部执行失败。原子性的保证依靠**锁**和**回滚**(rollback)。

   **回滚**：借助**版本**机制，记录事务内每个**事务单元**执行前的被操作数据的状态。由于事务内的事务单元都是有序执行的，当执行到某个事务单元发生异常需要回滚时，按照执行顺序的逆序恢复被操作数据的状态。

   

2. 一致性(Consistency)

   一致性保证应用程序只能看到**初始的一致状态**或者**最终的一致状态**，而不能看见**中间状态**，即确保数据库的状态从一个一致状态转变为另一个一致状态。一致性的保证依靠**锁**。

   

3. 隔离性(Isolation)

   隔离性保证多个事务并发执行时，一个事务的执行不应影响其他事务的执行。

   **锁分离**：使用多个锁来控制没有冲突的事务，每个事务都有自己的锁，这样就可以让没有冲突的事务并行的执行，提高并行度。

   **读写锁**：把控制事务的锁拆分成读写锁，使用读写锁后，事务内部的所有读操作都可以并行执行，提高速度。

   **READ_UNCOMMITED**: 不要锁，直接搞，读写、读读、写写并行。（性能最好，一致性最弱，并发能力最好）

   **READ_COMMITED**: 对数据加读锁时，允许写操作进入，读锁升级为写锁，读写、读读并行。

   **REPEATABLE_READ**: 对数据加读锁时，不允许写操作进入，读读并行。

   **SERIALIZABLE**: 将所有事务排队，只能串行化执行事务，使用排他锁。（性能最弱，一致性最强，并发能力最差）

   

4. 持久性(Duration)

   持久性保证已被提交的事务对数据库的修改应该永久保存在数据库中。如果一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，接下来的其他操作或故障不应该对其有任何影响。

   在很多数据库系统中，由于**性能**的原因，事务操作时，并不是数据每次被修改后立即被写入磁盘，而是采用**异步刷盘**的模式。持久性就是为了保证这些在缓存中的数据，在故障（硬件损坏或者断电等）恢复后，仍然能够正确的写入磁盘。

   1. 如果在事务**提交之前**发生故障，那么缓存的数据丢失，修改的信息也就丢失了，数据库只能根据**日志**做回滚。

   2. 如果在事务**提交之后**发生故障，即使缓存中的数据丢失，仍然可以根据**日志**将事务单元继续提交，整个事务仍然是成功的，不会导致任何数据丢失。

      简单的说，就是在对数据库更新时，一定要保证日志已经写入磁盘，如果日志没有写入磁盘，故障发生后，数据只能丢失。

## 1.2. 事务的传播机制

# 2. 索引

## 2.1. 索引的数据结构

B-树&B+树

## 2.2. 聚集索引和非聚集索引（顺序）

### 2.2.1. 区别

- 聚集索引一个表**只能有一个**，而非聚集索引一个表可以存在多个
- 聚集索引存储记录是**物理上连续存在**，而非聚集索引是逻辑上的连续，物理存储并不连续
- 聚集索引:物理存储按照索引排序；聚集索引是一种**索引组织形式**，索引的键值逻辑顺序决定了表数据行的物理存储顺序。
  非聚集索引:物理存储不按照索引排序；非聚集索引就是普通索引，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序。
- 索引是通过二叉树（B-树/B+树）的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是**数据节点**。而非聚簇索引的叶节点仍然是**索引节点**，只不过有一个指针指向对应的数据块。

### 2.2.1. 优劣

插入数据时，聚集索引速度更慢（时间花费在“物理存储的排序”上，也就是首先要找到位置然后插入；非聚集索引直接在末尾插入就行）

查询数据时，聚集索引速度更快（聚集索引的排列顺序就是数据行的排列顺序，无论是物理还是逻辑顺序；非聚集索引要先找到符合条件的索引，再找到根据找到对应的数据行）

## 2.3. 聚簇索引和非聚簇索引（物理结构）

## 2.3. 索引的类别

主键索引&非主键索引

聚集索引&辅助索引(InnoDB)

普通索引、唯一索引、主键索引、组合索引、外键索引（仅InnoDB支持，不怎么用）、全文索引（数据库有自带的，但仅支持InnoDB、MyISAM；也可以借助全文索引引擎，如Elasticsearch、Solr）