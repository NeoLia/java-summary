[TOC]

# 1. 事务

## 1.1. 事务的特性

1. 原子性(Atomicity)

   原子性保证一个事务内的所有事务单元（对数据库的操作）那么全部执行成功，要么全部执行失败。原子性的保证依靠**锁**和**回滚**(rollback)。

   **回滚**：借助**版本**机制，记录事务内每个**事务单元**执行前的被操作数据的状态。由于事务内的事务单元都是有序执行的，当执行到某个事务单元发生异常需要回滚时，按照执行顺序的逆序恢复被操作数据的状态。

   

2. 一致性(Consistency)

   一致性保证应用程序只能看到**初始的一致状态**或者**最终的一致状态**，而不能看见**中间状态**，即确保数据库的状态从一个一致状态转变为另一个一致状态。一致性的保证依靠**锁**。

   

3. 隔离性(Isolation)

   隔离性保证多个事务并发执行时，一个事务的执行不应影响其他事务的执行。

   **锁分离**：使用多个锁来控制没有冲突的事务，每个事务都有自己的锁，这样就可以让没有冲突的事务并行的执行，提高并行度。

   **读写锁**：把控制事务的锁拆分成读写锁，使用读写锁后，事务内部的所有读操作都可以并行执行，提高速度。

   **READ_UNCOMMITED**: 不要锁，直接搞，读写、读读、写写并行。（性能最好，一致性最弱，并发能力最好）

   **READ_COMMITED**: 对数据加读锁时，允许写操作进入，读锁升级为写锁，读写、读读并行。

   **REPEATABLE_READ**: 对数据加读锁时，不允许写操作进入，读读并行。

   **SERIALIZABLE**: 将所有事务排队，只能串行化执行事务，使用排他锁。（性能最弱，一致性最强，并发能力最差）

   

4. 持久性(Duration)

   持久性保证已被提交的事务对数据库的修改应该永久保存在数据库中。如果一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，接下来的其他操作或故障不应该对其有任何影响。

   在很多数据库系统中，由于**性能**的原因，事务操作时，并不是数据每次被修改后立即被写入磁盘，而是采用**异步刷盘**的模式。持久性就是为了保证这些在缓存中的数据，在故障（硬件损坏或者断电等）恢复后，仍然能够正确的写入磁盘。

   1. 如果在事务**提交之前**发生故障，那么缓存的数据丢失，修改的信息也就丢失了，数据库只能根据**日志**做回滚。

   2. 如果在事务**提交之后**发生故障，即使缓存中的数据丢失，仍然可以根据**日志**将事务单元继续提交，整个事务仍然是成功的，不会导致任何数据丢失。

      简单的说，就是在对数据库更新时，一定要保证日志已经写入磁盘，如果日志没有写入磁盘，故障发生后，数据只能丢失。