[TOC]

# 1. 常见问题

## 1.1. 缓存穿透
### 1.1.1. 描述

缓存穿透是指当用户在查询一条数据的时候，而此时数据库和缓存却没有关于这条数据的任何记录，而这条数据在缓存中没找到就会向数据库请求获取数据。它拿不到数据时，是会一直查询数据库，这样会对数据库的访问造成很大的压力。
### 1.1.2. 解决方法
1. **缓存空对象**  
指一个请求发送过来，如果此时缓存中和数据库都不存在这个请求所要查询的相关信息，那么数据库就会返回一个空对象，并将这个空对象和请求关联起来存到缓存中，当下次还是这个请求过来的时候，这时缓存就会命中，就直接从缓存中返回这个空对象，这样可以减少访问数据库的压力，提高当前数据库的访问性能。
2. **布隆过滤器**  
它是一种基于概率的数据结构，主要使用爱判断当前某个元素是否在该集合中，运行速度快。我们也可以简单理解为是一个不怎么精确的 set 结构（set 具有去重的效果）。但是有个小问题是：当你使用它的 contains 方法去判断某个对象是否存在时，它可能会误判。也就是说布隆过滤器不是特别不精确，但是只要参数设置的合理，它的精确度可以控制的相对足够精确，只会有小小的误判概率。当布隆过滤器说某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在。
## 1.2. 缓存击穿
### 1.2.1. 描述
缓存击穿是指有某个经常被查询的key，在这个key的过期时间到了时，突然有大量有关这个key的访问请求；或者有某个经常不被访问的key，突然有大量有关这个key的访问请求。这样会导致大并发请求直接穿透缓存，请求数据库，瞬间对数据库的访问压力增大。
### 1.2.2. 解决方法
常用的解决方案是**加锁**。对于key过期的时候，当key要查询数据库的时候加上一把锁，这时只能让第一个请求进行查询数据库，然后把从数据库中查询到的值存储到缓存中，对于剩下的相同的key，可以直接从缓存中获取即可。  
如果我们是在单机环境下：直接使用常用的锁即可（如：Lock、Synchronized等），在分布式环境下我们可以使用分布式锁，如：基于数据库、基于Redis或者zookeeper 的分布式锁。
## 1.3. 缓存雪崩
### 1.3.1. 描述
缓存雪崩是指在某一个时间段内，缓存集中过期失效，如果这个时间段内有大量请求，而查询数据量巨大，所有的请求都会达到存储层，存储层的调用量会暴增，引起数据库压力过大甚至宕机。
### 1.3.2. 解决方法
1. **redis高可用**  
redis有可能挂掉，就多增加几台redis实例，（一主多从或者多主多从），这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。
2. **限流降级**  
在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量，对某个key只允许一个线程查询数据和写缓存，其他线程等待。
3. **数据预热**  
在正式部署之前，先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key。
4. **不同的过期时间**  
设置不同的过期时间，让缓存失效的时间点尽量均匀、错开。